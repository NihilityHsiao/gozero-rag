# 常见的多租户方案实现

| 方案                                              | 描述                                                                           | 优点                                                     | 缺点                                                                        | 适用场景                                                        |
| :------------------------------------------------ | :----------------------------------------------------------------------------- | :------------------------------------------------------- | :-------------------------------------------------------------------------- | :-------------------------------------------------------------- |
| **1. 独立数据库**<br>(Database per Tenant)        | 每个租户一个独立的物理数据库。<br>物理隔离。                                   | 数据绝对隔离，安全性最高，故障爆炸半径小，备份恢复容易。 | 成本极其高昂，运维复杂，资源利用率低（大量闲置连接）。                      | 银行/金融类、对合规性要求极高的 Enterprise 业务。               |
| **2. 共享库，独立 Schema**<br>(Schema per Tenant) | 所有租户共用个物理库，但每租户属于不同的 Postgres Schema 或 MySQL Table 前缀。 | 在逻辑隔离和成本之间取得了平衡。                         | 跨租户统计困难，数据库连接池管理依然有一定复杂度，MySQL对Schema支持不如PG。 | 中型 SaaS，需要一定隔离性但预算有限。                           |
| **3. 共享库，共享 Schema**<br>(Shared Database)   | 所有租户共用同一个库、同一张表。<br>通过 `tenant_id` 字段区分。                | 成本最低，开发最快，资源利用率最高，易于水平扩展。       | 代码层必须严格控制隔离，容易因 WHERE 条件遗漏导致数据泄露。                 | 绝大多数现代 SaaS，互联网创业项目，ToB 通用工具（如 RAGFlow）。 |



# gozero-RAG 采用的方案

**采用方案 3：共享库，共享 Schema（逻辑隔离）**

在私有部署场景下，企业就是一个大租户，或者企业内部只有几个部门使用。此时搞"一租户一库"的设计是过度设计，会给部署带来巨大的负担（需要创建几百个 DB）。

特别是对于 **RAG 场景**，核心不仅仅是 MySQL，还有 Milvus/Elasticsearch 等向量/全文检索引擎。
*   向量数据库本身也是通过 Collection + Partition 或者 **Metadata Filtering** 来实现多租户的。
*   如果在 MySQL 层做物理隔离，那么在 Milvus 层也需要做对应的物理隔离（如每个租户一个 Collection），这会导致 Milvus 资源消耗爆炸（Milvus 加载 Collection 需要消耗大量内存，不可能为每个租户建一个）。

因此，通过 `tenant_id` 在逻辑上实现多租户是该项目成本最低、可行性最高的方案。

---

# 数据库表设计

## 核心表

### 1. user 表 (用户表)
```mysql
CREATE TABLE `user` (
  `id` varchar(32) NOT NULL COMMENT '用户ID, UUID v7',
  `access_token` varchar(255) DEFAULT NULL COMMENT '访问令牌',
  `nickname` varchar(100) NOT NULL COMMENT '昵称',
  `password` varchar(255) DEFAULT NULL COMMENT '密码 hash',
  `email` varchar(255) NOT NULL COMMENT '邮箱',
  `avatar` longtext COMMENT '头像base64字符串',
  `language` varchar(32) DEFAULT 'Chinese' COMMENT '语言: English|Chinese',
  `color_schema` varchar(32) DEFAULT 'Bright' COMMENT '主题: Bright|Dark',
  `timezone` varchar(64) DEFAULT 'UTC+8\tAsia/Shanghai' COMMENT '时区',
  `last_login_time` datetime DEFAULT NULL COMMENT '最后登录时间',
  `is_active` tinyint NOT NULL DEFAULT 1 COMMENT '是否激活(登录核心校验字段): 0-禁用不可登录, 1-激活可登录',
  `login_channel` varchar(255) DEFAULT NULL COMMENT '登录渠道',
  `status` tinyint NOT NULL DEFAULT 1 COMMENT '状态: 0-废弃, 1-有效',
  `is_superuser` tinyint NOT NULL DEFAULT 0 COMMENT '是否超级管理员',
  `create_time` bigint NOT NULL COMMENT '创建时间戳(ms)',
  `update_time` bigint NOT NULL COMMENT '更新时间戳(ms)',
  `create_date` datetime NOT NULL COMMENT '创建日期',
  `update_date` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_email` (`email`),
  KEY `idx_nickname` (`nickname`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';
```

### 2. tenant 表 (租户表)
```mysql
CREATE TABLE `tenant` (
  `id` varchar(32) NOT NULL COMMENT '租户ID (通常与创建者user_id相同)',
  `name` varchar(100) DEFAULT NULL COMMENT '租户名称/工作空间名称',
  `llm_id` varchar(128) NOT NULL default '' COMMENT '默认LLM模型ID',
  `embd_id` varchar(128) NOT NULL default '' COMMENT '默认Embedding模型ID',
  `asr_id` varchar(128) NOT NULL default '' COMMENT '默认ASR模型ID',
  `img2txt_id` varchar(128) NOT NULL default '' COMMENT '默认图片转文字模型ID',
  `rerank_id` varchar(128) NOT NULL default '' COMMENT '默认重排序模型ID',
  `tts_id` varchar(256) NOT NULL default '' COMMENT '默认TTS模型ID',
  `parser_ids` varchar(256) NOT NULL default '' COMMENT '文档处理器列表',
  `credit` int NOT NULL DEFAULT 512 COMMENT '积分',
  `status` tinyint DEFAULT 1 COMMENT '状态: 1=正常, 0=禁用',
  `create_time` bigint NOT NULL COMMENT '创建时间戳',
  `update_time` bigint NOT NULL COMMENT '更新时间戳',
  `create_date` datetime NOT NULL COMMENT '创建日期',
  `update_date` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='租户表';
```

### 3. user_tenant 表 (用户-租户关联表)
```mysql
CREATE TABLE `user_tenant` (
  `id` varchar(32) NOT NULL COMMENT '记录ID',
  `user_id` varchar(32) NOT NULL COMMENT '用户ID',
  `tenant_id` varchar(32) NOT NULL COMMENT '租户ID',
  `role` varchar(32) NOT NULL COMMENT '角色: owner|admin|member',
  `invited_by` varchar(32) NOT NULL COMMENT '邀请人ID',
  `status` tinyint DEFAULT 1 COMMENT '状态: 0-废弃, 1-有效',
  `create_time` bigint NOT NULL COMMENT '创建时间戳',
  `update_time` bigint NOT NULL COMMENT '更新时间戳',
  `create_date` datetime NOT NULL COMMENT '创建日期',
  `update_date` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_tenant` (`user_id`, `tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`),
  KEY `idx_role` (`role`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户租户关联表';
```

> **角色说明 (UserTenantRole)**:
> - `owner`: 租户所有者，拥有全部权限，可删除租户
> - `admin`: 管理员，可管理成员和资源
> - `member`: 普通成员，只能使用资源

---

# 注册登录改造

## 改造前后对比

| 项目     | 改造前                     | 改造后                                                |
| :------- | :------------------------- | :---------------------------------------------------- |
| 用户ID   | `int64` 自增               | `varchar(32)` UUID v7                                 |
| 登录参数 | `username` + `password`    | `email` + `password`                                  |
| 注册参数 | `username` + `email` + ... | `nickname` + `email` + `password`                     |
| 登录返回 | `UserInfo` + `JwtToken`    | `UserInfo` + `JwtToken` + `TenantInfo` + `TenantList` |
| 租户处理 | 无                         | 注册时自动创建个人租户                                |

## API 定义

### 文件: `restful/rag/api/common.api`

```go
syntax = "v1"

type (
    // 用户基本信息 (改造后)
    UserInfo {
        UserId   string `json:"user_id"`   // UUID v7
        Nickname string `json:"nickname"`
        Email    string `json:"email"`
        Avatar   string `json:"avatar,optional"`
        Language string `json:"language,optional"`
    }

    // JWT Token
    JwtToken {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        ExpireAt     int64  `json:"expire_at"`       // 秒级时间戳
    }

    // 租户基本信息
    TenantInfo {
        TenantId string `json:"tenant_id"`
        Name     string `json:"name"`
        Role     string `json:"role"`   // owner|admin|member
    }
)
```

### 文件: `restful/rag/api/login_and_register.api`

```go
syntax = "v1"
import "./common.api"

type (
    // 登录请求 (改造后: 使用Email登录)
    LoginRequest {
        Email    string `json:"email"`
        Password string `json:"password"`
    }

    // 登录响应 (改造后: 包含租户信息)
    LoginResponse {
        Token         JwtToken     `json:"token"`
        User          UserInfo     `json:"user"`
        CurrentTenant TenantInfo   `json:"current_tenant"`  // 当前活跃租户
        Tenants       []TenantInfo `json:"tenants"`         // 用户关联的所有租户
    }

    // 注册请求 (改造后)
    RegisterRequest {
        Nickname        string `json:"nickname"`
        Email           string `json:"email"`
        Password        string `json:"password"`
        ConfirmPassword string `json:"confirm_password"`
    }

    // 注册响应 (复用 LoginResponse, 注册后自动登录)
)

@server (
    group  : login
    prefix : /v1
    tags   : "用户登录和注册"
)
service rag {
    @handler login
    post /user/login (LoginRequest) returns (LoginResponse)

    @handler register
    post /user/register (RegisterRequest) returns (LoginResponse)
}
```

---

## 注册流程 (Register)

```
┌─────────────────────────────────────────────────────────────────────┐
│                        用户提交注册表单                               │
│                 (nickname, email, password)                          │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 参数校验                                                          │
│    - email 格式校验                                                  │
│    - password == confirm_password                                    │
│    - 检查 email 是否已存在                                           │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 创建用户 (INSERT user)                                            │
│    - id = UUID v7                                                    │
│    - password = bcrypt(password)                                     │
│    - 其他字段使用默认值                                               │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. 创建租户 (INSERT tenant)                                          │
│    - tenant.id = user.id (首次注册，用户即租户所有者)                  │
│    - tenant.name = user.nickname + "的工作空间"                       │
│    - 默认模型ID全为空 (业务中按需提醒设置)                             │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. 创建用户-租户关联 (INSERT user_tenant)                             │
│    - user_id = user.id                                               │
│    - tenant_id = tenant.id                                           │
│    - role = "owner"                                                  │
│    - invited_by = user.id (自己创建)                                 │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. 生成 Token 并返回                                                  │
│    - 生成 access_token, refresh_token                                │
│    - 返回 UserInfo + JwtToken + TenantInfo                           │
└─────────────────────────────────────────────────────────────────────┘
```

**关键代码逻辑 (伪代码):**
```go
func (l *RegisterLogic) Register(req *types.RegisterRequest) (*types.LoginResponse, error) {
    // 1. 校验
    if req.Password != req.ConfirmPassword {
        return nil, xerr.NewErrCodeMsg(xerr.BadRequest, "两次密码不一致")
    }
    
    // 检查邮箱是否已存在
    _, err := l.svcCtx.UserModel.FindOneByEmail(l.ctx, req.Email)
    if err == nil {
        return nil, xerr.NewErrCodeMsg(xerr.UserAlreadyExists, "邮箱已被注册")
    }

    // 2. 生成 UUID v7
    userId := uuid.Must(uuid.NewV7()).String()
    now := time.Now()
    
    // 3. 创建用户
    passwordHash, _ := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    user := &user.User{
        Id:       userId,
        Nickname: req.Nickname,
        Email:    req.Email,
        Password: sql.NullString{String: string(passwordHash), Valid: true},
        // ... 其他字段
    }
    _, err = l.svcCtx.UserModel.Insert(l.ctx, user)
    
    // 4. 创建租户 (事务)
    tenantId := userId  // 租户ID = 用户ID
    tenant := &tenant.Tenant{
        Id:   tenantId,
        Name: sql.NullString{String: req.Nickname + "的工作空间", Valid: true},
        // 默认模型全为空
    }
    _, err = l.svcCtx.TenantModel.Insert(l.ctx, tenant)
    
    // 5. 创建关联
    userTenant := &user_tenant.UserTenant{
        Id:        uuid.Must(uuid.NewV7()).String(),
        UserId:    userId,
        TenantId:  tenantId,
        Role:      "owner",
        InvitedBy: userId,
    }
    _, err = l.svcCtx.UserTenantModel.Insert(l.ctx, userTenant)
    
    // 6. 生成Token并返回
    // ...
}
```

---

## 登录流程 (Login)

```
┌─────────────────────────────────────────────────────────────────────┐
│                        用户提交登录表单                               │
│                      (email, password)                               │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 参数校验                                                          │
│    - email, password 非空                                            │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 查询用户                                                          │
│    - SELECT * FROM user WHERE email = ?                              │
│    - 用户不存在 → 返回错误                                           │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. 密码验证                                                          │
│    - bcrypt.CompareHashAndPassword(db_password, input_password)      │
│    - 密码错误 → 返回错误                                             │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. 状态检查                                                          │
│    - is_active == 0 → 返回"账户已被禁用"                              │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. 查询用户关联的租户列表                                             │
│    - SELECT t.*, ut.role FROM tenant t                               │
│      JOIN user_tenant ut ON t.id = ut.tenant_id                       │
│      WHERE ut.user_id = ? AND ut.status = 1                          │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. 更新用户状态                                                       │
│    - 生成新的 access_token (存入user.access_token)                    │
│    - 更新 last_login_time                                            │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 7. 生成 JWT Token                                                    │
│    - Claims: user_id, tenant_id (当前租户, 默认第一个)                │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 8. 返回结果                                                          │
│    - UserInfo + JwtToken + CurrentTenant + Tenants[]                 │
└─────────────────────────────────────────────────────────────────────┘
```

---

# 后端改动清单

## 文件改动

| 文件路径                                             | 改动类型 | 说明                               |
| :--------------------------------------------------- | :------- | :--------------------------------- |
| `restful/rag/api/common.api`                         | MODIFY   | 更新 `UserInfo`, 新增 `TenantInfo` |
| `restful/rag/api/login_and_register.api`             | MODIFY   | 更新登录/注册请求和响应结构        |
| `restful/rag/internal/logic/login/login_logic.go`    | MODIFY   | 实现新登录逻辑，查询租户列表       |
| `restful/rag/internal/logic/login/register_logic.go` | MODIFY   | 实现新注册逻辑，创建租户和关联     |
| `internal/model/user/user_model.go`                  | MODIFY   | 新增 `FindOneByEmail` 方法         |
| `internal/model/user_tenant/user_tenant_model.go`    | MODIFY   | 新增 `FindByUserId` 方法           |

## 需要新增的 Model 方法

```go
// user_model.go
func (m *customUserModel) FindOneByEmail(ctx context.Context, email string) (*User, error)

// user_tenant_model.go  
func (m *customUserTenantModel) FindByUserId(ctx context.Context, userId string) ([]*UserTenant, error)

// 或者创建自定义查询，JOIN 租户表返回完整信息
type UserTenantWithTenant struct {
    UserTenant
    TenantName string `db:"tenant_name"`
}
func (m *customUserTenantModel) FindTenantsWithInfoByUserId(ctx context.Context, userId string) ([]*UserTenantWithTenant, error)
```

---

# 前端改动清单

## 类型定义 (`fe/src/types/`)

### `index.ts` 改动
```typescript
// 改造后
export interface UserInfo {
  user_id: string;      // 改为 string (UUID)
  nickname: string;     // username → nickname
  email: string;
  avatar?: string;
  language?: string;
}

export interface JwtToken {
  access_token: string;
  refresh_token: string;
  expire_at: number;
  // 移除 uid，改为在 UserInfo 中包含
}

// 新增
export interface TenantInfo {
  tenant_id: string;
  name: string;
  role: 'owner' | 'admin' | 'member';
}
```

### `auth.ts` 改动
```typescript
export interface LoginResponse {
  token: JwtToken;
  user: UserInfo;
  current_tenant: TenantInfo;   // 新增
  tenants: TenantInfo[];        // 新增
}
```

## Store (`fe/src/store/useAuthStore.ts`)

```typescript
interface AuthState {
  token: string | null;
  userInfo: UserInfo | null;
  currentTenant: TenantInfo | null;    // 新增
  tenants: TenantInfo[];                // 新增
  isAuthenticated: boolean;
  login: (data: LoginResponse) => void;
  logout: () => void;
  switchTenant: (tenantId: string) => void;  // 新增: 切换租户
}
```

## API 请求 (`fe/src/api/auth.ts`)

```typescript
export interface LoginReq {
  email: string;      // username → email
  password: string;
}

export interface RegisterReq {
  nickname: string;
  email: string;
  password: string;
  confirm_password: string;
}

export const login = (data: LoginReq) => {
  return request.post<any, LoginResponse>('/user/login', data);
};

export const register = (data: RegisterReq) => {
  return request.post<any, LoginResponse>('/user/register', data);
};
```

## 页面组件 (`fe/src/pages/auth/Login.tsx`)

1. 表单字段: `username` → `email`
2. 登录成功后: 存储 `currentTenant` 和 `tenants` 到 store
3. (可选) 添加注册页面/模式切换

---

# 第一阶段目标 (已完成)

> 只做登录和注册的多租户改造，其他功能保持不变。

## ✅ 完成标准

1. **注册成功后**:
   - 创建 `user` 记录
   - 创建 `tenant` 记录 (id = user.id)
   - 创建 `user_tenant` 记录 (role = owner)
   - 自动登录并返回 Token

2. **登录成功后**:
   - 返回用户关联的所有租户列表
   - 返回当前活跃租户 (默认第一个)
   - 前端存储租户信息

3. **前端 UI**:
   - 登录页使用 email 登录
   - (可选) 新增注册页面
   - 登录后能在 Header 显示当前租户名称

## ❌ 暂不实现

- 租户切换功能
- 邀请成员加入租户
- 租户设置页面
- 业务数据的 `tenant_id` 隔离 (知识库、文档等)

---

# 影响的后端接口文件

- `restful/rag/api/common.api`
- `restful/rag/api/login_and_register.api`
- `restful/rag/internal/logic/login/login_logic.go`
- `restful/rag/internal/logic/login/register_logic.go`

---

# 代码生成规范

> ⚠️ **重要**: 禁止直接使用 `goctl` 命令生成代码，必须使用项目 Makefile 中提供的命令。

## 修改 SQL 文件后

当修改了 `script/mysql/*.sql` 文件后，运行：

```bash
make gen-model
```

## 修改 API 文件后

当修改了 `restful/rag/api/*.api` 或 `restful/rag/rag.api` 文件后，运行：

```bash
make gen-api
```

## 原因说明

1. Makefile 中的命令使用了自定义模板 (`--home ./tpl`)，确保生成的代码符合项目规范
2. 自定义模板包含自动填充时间戳等增强功能
3. 直接使用 `goctl` 会丢失这些自定义配置


# 第二阶段目标：LLM Factories 多租户改造

> 实现租户级别的 LLM 模型配置管理，让每个租户可以独立配置自己的 LLM 厂商和模型。

---

## 改造背景

**现状问题**：
- 当前模型配置存储在 `user_api` 表，绑定到用户而非租户
- 没有系统支持的厂商列表，用户需要手动填写所有信息
- 不同用户添加同一厂商的模型需要重复填写 `api_key` 和 `api_base`

**改造目标**：
- 新增 `llm_factories` 表存储系统支持的 LLM 厂商
- 新增 `tenant_llm` 表实现租户级别的模型配置
- 用户选择厂商后，可以一次性添加该厂商的多个不同类型模型（共享同一 api_key/api_base）

---

## 表结构设计

### 1. llm_factories 表 (LLM厂商表)

> 系统级配置表，存储 gozero-rag 支持的所有 LLM 厂商信息。

```mysql
CREATE TABLE `llm_factories` (
  `name` varchar(128) NOT NULL COMMENT 'LLM厂商名称 (主键)',
  `logo` longtext COMMENT '厂商Logo base64',
  `tags` varchar(255) NOT NULL COMMENT '支持的模型类型: LLM,Embedding,Rerank,ASR,TTS,Image2Text,Text2Image,Video',
  `rank` int NOT NULL DEFAULT 0 COMMENT '排序权重, 越大越靠前',
  `status` tinyint NOT NULL DEFAULT 1 COMMENT '状态: 0-禁用, 1-有效',
  `created_time` bigint NOT NULL COMMENT '创建时间戳(ms)',
  `updated_time` bigint NOT NULL COMMENT '更新时间戳(ms)',
  `created_date` datetime NOT NULL COMMENT '创建日期',
  `updated_date` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`name`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='LLM厂商表';
```

**支持的模型类型 (tags)**：

| 类型         | 说明       | 用途                      |
| :----------- | :--------- | :------------------------ |
| `LLM`        | 对话模型   | Chat、问答生成、Query重写 |
| `Embedding`  | 嵌入模型   | 文档向量化                |
| `Rerank`     | 重排序模型 | 检索结果重排序            |
| `ASR`        | 语音识别   | 音频转文字                |
| `TTS`        | 语音合成   | 文字转语音                |
| `Image2Text` | 图片转文字 | OCR、图片描述             |
| `Text2Image` | 文字转图片 | 图像生成                  |
| `Video`      | 视频生成   | 视频内容生成              |

### 2. tenant_llm 表 (租户LLM配置表)

> 租户级配置表，存储每个租户配置的 LLM 模型。

```mysql
CREATE TABLE `tenant_llm` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `tenant_id` varchar(36) NOT NULL COMMENT '租户ID',
  `llm_factory` varchar(128) NOT NULL COMMENT 'LLM厂商名称 (关联 llm_factories.name)',
  `model_type` varchar(32) NOT NULL COMMENT '模型类型: LLM,Embedding,Rerank,ASR,TTS,Image2Text,Text2Image,Video',
  `llm_name` varchar(128) NOT NULL COMMENT 'LLM模型名称 (如: deepseek-ai/DeepSeek-V3)',
  `api_key` longtext COMMENT 'API密钥 (明文存储)',
  `api_base` varchar(255) DEFAULT NULL COMMENT 'API基础地址',
  `max_tokens` int NOT NULL DEFAULT 8192 COMMENT '最大Token数',
  `used_tokens` int NOT NULL DEFAULT 0 COMMENT '已使用Token数',
  `status` tinyint NOT NULL DEFAULT 1 COMMENT '状态: 0-禁用, 1-有效',
  `created_time` bigint NOT NULL COMMENT '创建时间戳(ms)',
  `updated_time` bigint NOT NULL COMMENT '更新时间戳(ms)',
  `created_date` datetime NOT NULL COMMENT '创建日期',
  `updated_date` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_factory_type_llm` (`tenant_id`, `llm_factory`, `model_type`, `llm_name`),
  KEY `idx_tenant_id` (`tenant_id`),
  KEY `idx_llm_factory` (`llm_factory`),
  KEY `idx_model_type` (`model_type`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='租户LLM配置表';
```

**唯一约束说明**：
- `uk_tenant_factory_type_llm`: 同一租户、同一厂商、同一类型下，模型名称必须唯一
- 允许同一租户添加多个相同类型的模型（如多个 Embedding 模型）

---

## API 设计

> **命名规范**:
> - API 文件按数据库表名称命名，如 `llm_factories.sql` 对应 `llm_factories.api`
> - 所有 API 必须有 `jwt: Auth` 认证和 `group` 分组
> - 请求类型以 `Req` 结尾，响应类型以 `Resp` 结尾

### 文件: `restful/rag/api/llm_factories.api`

```go
syntax = "v1"
import "./common.api"

type (
    // 厂商信息
    LlmFactoryInfo {
        Name    string   `json:"name"`
        Logo    string   `json:"logo"`
        Tags    string   `json:"tags"`       // 逗号分隔的模型类型
        TagList []string `json:"tag_list"`   // 拆分后的类型数组
        Rank    int64    `json:"rank"`
        Status  int64    `json:"status"`
    }

    // 获取厂商列表请求
    ListLlmFactoriesReq {
    }

    // 获取厂商列表响应
    ListLlmFactoriesResp {
        List []LlmFactoryInfo `json:"list"`
    }
)

@server (
    jwt    : Auth
    tags   : "大模型厂商"
    prefix : /v1
    group  : llm_factories
)
service rag {
    @doc "获取系统支持的LLM厂商列表"
    @handler listLlmFactories
    get /llm/factories (ListLlmFactoriesReq) returns (ListLlmFactoriesResp)
}
```

---

### 文件: `restful/rag/api/tenant_llm.api`

```go
syntax = "v1"
import "./common.api"

type (
    // 租户LLM配置信息
    TenantLlmInfo {
        Id          int64  `json:"id"`
        TenantId    string `json:"tenant_id"`
        LlmFactory  string `json:"llm_factory"`
        ModelType   string `json:"model_type"`
        LlmName     string `json:"llm_name"`
        ApiKey      string `json:"api_key"`       // 返回时脱敏处理
        ApiBase     string `json:"api_base"`
        MaxTokens   int64  `json:"max_tokens"`
        UsedTokens  int64  `json:"used_tokens"`
        Status      int64  `json:"status"`
        CreatedTime int64  `json:"created_time"`
        UpdatedTime int64  `json:"updated_time"`
    }

    // 批量添加模型的单个模型配置
    ModelConfig {
        ModelType string `json:"model_type"`       // LLM, Embedding, Rerank, ...
        LlmName   string `json:"llm_name"`         // 模型名称
        MaxTokens int64  `json:"max_tokens,optional,default=8192"`
    }

    // 批量添加租户LLM配置请求
    AddTenantLlmReq {
        LlmFactory string        `json:"llm_factory"`      // 厂商名称
        ApiKey     string        `json:"api_key"`          // 共享的API密钥
        ApiBase    string        `json:"api_base"`         // 共享的API基础地址
        Models     []ModelConfig `json:"models"`           // 要添加的模型列表
    }

    // 批量添加租户LLM配置响应
    AddTenantLlmResp {
        SuccessCount int64    `json:"success_count"`    // 成功添加数量
        FailedCount  int64    `json:"failed_count"`     // 失败数量
        FailedModels []string `json:"failed_models"`    // 失败的模型名称
    }

    // 获取租户LLM配置列表请求
    ListTenantLlmReq {
        LlmFactory string `form:"llm_factory,optional"` // 按厂商筛选
        ModelType  string `form:"model_type,optional"`  // 按类型筛选
        Status     int64  `form:"status,optional"`      // 按状态筛选
        Page       int64  `form:"page,optional,default=1"`
        PageSize   int64  `form:"page_size,optional,default=20"`
    }

    // 获取租户LLM配置列表响应
    ListTenantLlmResp {
        Total int64           `json:"total"`
        List  []TenantLlmInfo `json:"list"`
    }

    // 更新租户LLM配置请求
    UpdateTenantLlmReq {
        Id        int64  `path:"id"`
        ApiKey    string `json:"api_key,optional"`
        ApiBase   string `json:"api_base,optional"`
        MaxTokens int64  `json:"max_tokens,optional"`
        Status    int64  `json:"status,optional"`
    }

    // 删除租户LLM配置请求
    DeleteTenantLlmReq {
        Id int64 `path:"id"`
    }

    // 按厂商分组的模型列表
    TenantLlmGroupByFactory {
        LlmFactory  string          `json:"llm_factory"`
        FactoryLogo string          `json:"factory_logo"`
        ApiBase     string          `json:"api_base"`
        Models      []TenantLlmInfo `json:"models"`
    }

    // 获取按厂商分组的列表响应
    ListTenantLlmGroupedResp {
        List []TenantLlmGroupByFactory `json:"list"`
    }
)

@server (
    jwt    : Auth
    tags   : "租户LLM配置"
    prefix : /v1
    group  : tenant_llm
)
service rag {
    @doc "批量添加租户LLM配置"
    @handler addTenantLlm
    post /tenant/llm (AddTenantLlmReq) returns (AddTenantLlmResp)

    @doc "获取租户LLM配置列表"
    @handler listTenantLlm
    get /tenant/llm (ListTenantLlmReq) returns (ListTenantLlmResp)

    @doc "获取租户LLM配置列表(按厂商分组)"
    @handler listTenantLlmGrouped
    get /tenant/llm/grouped (ListTenantLlmReq) returns (ListTenantLlmGroupedResp)

    @doc "更新租户LLM配置"
    @handler updateTenantLlm
    put /tenant/llm/:id (UpdateTenantLlmReq)

    @doc "删除租户LLM配置"
    @handler deleteTenantLlm
    delete /tenant/llm/:id (DeleteTenantLlmReq)
}
```

---

### 文件: `restful/rag/api/knowledge_base.api`

```go
syntax = "v1"
import "./common.api"

type (
    // 知识库基本信息
    KnowledgeBaseInfo {
        Id                     string `json:"id"`
        Avatar                 string `json:"avatar,optional"`
        TenantId               string `json:"tenant_id"`
        Name                   string `json:"name"`
        Language               string `json:"language"`
        Description            string `json:"description,optional"`
        EmbdId                 string `json:"embd_id"`
        Permission             string `json:"permission"`
        CreatedBy              string `json:"created_by"`
        DocNum                 int64  `json:"doc_num"`
        TokenNum               int64  `json:"token_num"`
        ChunkNum               int64  `json:"chunk_num"`
        SimilarityThreshold    float64 `json:"similarity_threshold"`
        VectorSimilarityWeight float64 `json:"vector_similarity_weight"`
        Status                 int64  `json:"status"`
        CreatedTime            int64  `json:"created_time"`
        UpdatedTime            int64  `json:"updated_time"`
    }

    // 创建知识库请求
    CreateKnowledgeBaseReq {
        Name                   string  `json:"name"`
        Avatar                 string  `json:"avatar,optional"`
        Language               string  `json:"language,optional,default=Chinese"`
        Description            string  `json:"description,optional"`
        EmbdId                 string  `json:"embd_id"`
        Permission             string  `json:"permission,optional,default=me"`
        SimilarityThreshold    float64 `json:"similarity_threshold,optional,default=0.3"`
        VectorSimilarityWeight float64 `json:"vector_similarity_weight,optional,default=0.3"`
    }

    // 创建知识库响应
    CreateKnowledgeBaseResp {
        KnowledgeBaseInfo
    }

    // 获取知识库列表请求
    ListKnowledgeBaseReq {
        Page     int64  `form:"page,optional,default=1"`
        PageSize int64  `form:"page_size,optional,default=20"`
        Keyword  string `form:"keyword,optional"`
    }

    // 获取知识库列表响应
    ListKnowledgeBaseResp {
        Total int64               `json:"total"`
        List  []KnowledgeBaseInfo `json:"list"`
    }

    // 获取知识库详情请求
    GetKnowledgeBaseReq {
        Id string `path:"id"`
    }

    // 获取知识库详情响应
    GetKnowledgeBaseResp {
        KnowledgeBaseInfo
    }

    // 更新知识库请求
    UpdateKnowledgeBaseReq {
        Id                     string  `path:"id"`
        Name                   string  `json:"name,optional"`
        Avatar                 string  `json:"avatar,optional"`
        Language               string  `json:"language,optional"`
        Description            string  `json:"description,optional"`
        Permission             string  `json:"permission,optional"`
        SimilarityThreshold    float64 `json:"similarity_threshold,optional"`
        VectorSimilarityWeight float64 `json:"vector_similarity_weight,optional"`
        Status                 int64   `json:"status,optional"`
    }
    
    // 更新知识库响应
    UpdateKnowledgeBaseResp {
    }

    // 删除知识库请求
    DeleteKnowledgeBaseReq {
        Id string `path:"id"`
    }
    
    // 删除知识库响应
    DeleteKnowledgeBaseResp {
    }
)

@server (
    group  : knowledge_base
    prefix : /v1
    jwt    : Auth
    tags   : "知识库管理"
)
service rag {
    @doc "创建知识库"
    @handler CreateKnowledgeBase
    post /knowledge_base (CreateKnowledgeBaseReq) returns (CreateKnowledgeBaseResp)

    @doc "获取知识库列表"
    @handler ListKnowledgeBase
    get /knowledge_base (ListKnowledgeBaseReq) returns (ListKnowledgeBaseResp)

    @doc "获取知识库详情"
    @handler GetKnowledgeBase
    get /knowledge_base/:id (GetKnowledgeBaseReq) returns (GetKnowledgeBaseResp)

    @doc "更新知识库"
    @handler UpdateKnowledgeBase
    put /knowledge_base/:id (UpdateKnowledgeBaseReq) returns (UpdateKnowledgeBaseResp)

    @doc "删除知识库"
    @handler DeleteKnowledgeBase
    delete /knowledge_base/:id (DeleteKnowledgeBaseReq) returns (DeleteKnowledgeBaseResp)
}
```

### 文件: `restful/rag/api/knowledge_document.api`

```go
syntax = "v1"
import "./common.api"

type (
    // 文档信息
    KnowledgeDocumentInfo {
        Id              string  `json:"id"`
        KnowledgeBaseId string  `json:"knowledge_base_id"`
        DocName         string  `json:"doc_name"`
        DocType         string  `json:"doc_type"`
        DocSize         int64   `json:"doc_size"`
        StoragePath     string  `json:"storage_path"`
        Description     string  `json:"description"`
        Status          int64   `json:"status"`
        RunStatus       string  `json:"run_status"`
        ChunkNum        int64   `json:"chunk_num"`
        TokenNum        int64   `json:"token_num"`
        ParserConfig    string  `json:"parser_config"` // JSON string
        Progress        float64 `json:"progress"`
        ProgressMsg     string  `json:"progress_msg"`
        CreatedBy       string  `json:"created_by"`
        CreatedTime     int64   `json:"created_time"`
        UpdatedTime     int64   `json:"updated_time"`
    }

    // 获取文档列表请求
    ListKnowledgeDocumentReq {
        KnowledgeBaseId string `form:"knowledge_base_id"`
        Page            int64  `form:"page,optional,default=1"`
        PageSize        int64  `form:"page_size,optional,default=20"`
        Keyword         string `form:"keyword,optional"`
    }

    // 获取文档列表响应
    ListKnowledgeDocumentResp {
        Total int64                   `json:"total"`
        List  []KnowledgeDocumentInfo `json:"list"`
    }

    // 上传文件请求
    UploadDocumentReq {
        KnowledgeBaseId string `form:"knowledge_base_id"`
        // file: 实际文件字段，handler中处理
    }

    // 上传文件响应
    UploadDocumentResp {
        Id      string `json:"id"`
        DocName string `json:"doc_name"`
    }

    // 删除文档请求
    DeleteKnowledgeDocumentReq {
        Id string `path:"id"`
    }
    
    // 删除文档响应
    DeleteKnowledgeDocumentResp {
    }

    // 获取文档详情请求
    GetKnowledgeDocumentReq {
        Id string `path:"id"`
    }
    
    // 获取文档详情响应
    GetKnowledgeDocumentResp {
        KnowledgeDocumentInfo
    }
    
    // 更新文档解析配置请求
    UpdateDocumentParserConfigReq {
        Id           string `path:"id"`
        ParserConfig string `json:"parser_config"` // JSON string
    }
    
    // 更新文档解析配置响应
    UpdateDocumentParserConfigResp {
    }
    
    // 重新解析文档请求 (Retry)
    RetryDocumentReq {
        Id string `path:"id"`
    }
    
    // 重新解析文档响应
    RetryDocumentResp {
    }
)

@server (
    group  : knowledge_document
    prefix : /v1
    jwt    : Auth
    tags   : "知识库文档管理"
)
service rag {
    @doc "获取文档列表"
    @handler ListKnowledgeDocument
    get /knowledge_document (ListKnowledgeDocumentReq) returns (ListKnowledgeDocumentResp)

    @doc "上传文档"
    @handler UploadDocument
    post /knowledge_document/upload (UploadDocumentReq) returns (UploadDocumentResp)

    @doc "获取文档详情"
    @handler GetKnowledgeDocument
    get /knowledge_document/:id (GetKnowledgeDocumentReq) returns (GetKnowledgeDocumentResp)

    @doc "删除文档"
    @handler DeleteKnowledgeDocument
    delete /knowledge_document/:id (DeleteKnowledgeDocumentReq) returns (DeleteKnowledgeDocumentResp)
    
    @doc "更新文档解析配置"
    @handler UpdateDocumentParserConfig
    put /knowledge_document/:id/parser_config (UpdateDocumentParserConfigReq) returns (UpdateDocumentParserConfigResp)
    
    @doc "重试/重新解析文档"
    @handler RetryDocument
    post /knowledge_document/:id/retry (RetryDocumentReq) returns (RetryDocumentResp)
}
```

---

### 文件: `restful/rag/rag.api` (新增引用)

```go
syntax = "v1"

import "./api/common.api"
import "./api/login_and_register.api"
import "./api/user.api"
import "./api/knowledge.api"
import "./api/retrieval.api"
import "./api/chat.api"
import "./api/llm_factories.api"    // 新增
import "./api/tenant_llm.api"       // 新增

info (
    title:       "rag api 服务"
    desc:        "gozero实现的rag服务"
    author:      "LucasShaw"
    email:       "xyj.work@139.com"
    version:     "v1.0.0"
    host:        "127.0.0.1:8888"
    wrapCodeMsg: true
)
```

---

## 业务流程

### 添加厂商模型配置流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    用户进入模型配置页面                               │
│                  /settings/provider                                  │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 1. 获取系统支持的厂商列表                                             │
│    - GET /v1/llm/factories                                           │
│    - 返回: [{name, logo, tags, tag_list}, ...]                       │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 2. 用户点击【添加模型】                                               │
│    - 弹出 Dialog，展示厂商卡片列表                                    │
│    - 用户选择厂商 (如: SiliconFlow)                                   │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 3. 进入模型配置表单                                                   │
│    - 显示该厂商支持的模型类型 (从 tags 拆分)                          │
│    - 必填: api_key, api_base                                         │
│    - 每个类型一个输入框填写模型名称 (可选，留空则不添加)               │
│    ┌─────────────────────────────────────────────────────────┐       │
│    │ API Key:    [sk-xxxxxxxxxxxxx                      ]    │       │
│    │ API Base:   [https://api.siliconflow.cn/v1         ]    │       │
│    │ ─────────────────────────────────────────────────────   │       │
│    │ LLM:        [deepseek-ai/DeepSeek-V3              ]    │       │
│    │ Embedding:  [BAAI/bge-m3                          ]    │       │
│    │ Rerank:     [BAAI/bge-reranker-v2-m3              ]    │       │
│    │ ASR:        [                                      ]    │       │
│    │ TTS:        [                                      ]    │       │
│    │ ...                                                     │       │
│    └─────────────────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 4. 用户点击【确定】提交                                               │
│    - 前端过滤掉空值的模型类型                                         │
│    - POST /v1/tenant/llm                                             │
│    - Body: {llm_factory, api_key, api_base, models: [...]}          │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5. 后端处理                                                          │
│    - 从 JWT 获取 tenant_id                                           │
│    - 校验 llm_factory 是否存在于 llm_factories 表                    │
│    - 遍历 models，逐个插入 tenant_llm 表                             │
│    - 如遇唯一约束冲突，记录失败模型，继续处理其他                      │
│    - 返回成功/失败数量                                                │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6. 前端刷新列表                                                       │
│    - GET /v1/tenant/llm/grouped                                      │
│    - 展示按厂商分组的模型卡片                                         │
└─────────────────────────────────────────────────────────────────────┘
```

### 模型列表展示 (Dify 风格)

```
┌─────────────────────────────────────────────────────────────────────┐
│  模型配置                                          [+ 添加模型]      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ [Logo] SiliconFlow                              API: ✓ 已配置 │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │ LLM       │ deepseek-ai/DeepSeek-V3              [启用] [⋮] │   │
│  │ Embedding │ BAAI/bge-m3                          [启用] [⋮] │   │
│  │ Rerank    │ BAAI/bge-reranker-v2-m3              [启用] [⋮] │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ [Logo] OpenAI                                   API: ✓ 已配置 │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │ LLM       │ gpt-4o                               [启用] [⋮] │   │
│  │ Embedding │ text-embedding-3-large               [启用] [⋮] │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 后端改动清单

### 文件改动

| 文件路径                                      | 改动类型 | 说明                                     |
| :-------------------------------------------- | :------- | :--------------------------------------- |
| `script/mysql/llm_factories.sql`              | MODIFY   | 添加初始数据 (SiliconFlow)               |
| `script/mysql/tenant_llm.sql`                 | EXISTS   | 已存在，无需修改                         |
| `restful/rag/api/llm_factories.api`           | NEW      | 厂商相关 API 定义                        |
| `restful/rag/api/tenant_llm.api`              | NEW      | 租户LLM配置相关 API 定义                 |
| `restful/rag/rag.api`                         | MODIFY   | 引入 llm_factories.api 和 tenant_llm.api |
| `internal/model/llm_factories/`               | NEW      | 生成 Model 层代码                        |
| `internal/model/tenant_llm/`                  | NEW      | 生成 Model 层代码                        |
| `restful/rag/internal/logic/llm_factories/`   | NEW      | 厂商相关业务逻辑层                       |
| `restful/rag/internal/logic/tenant_llm/`      | NEW      | 租户LLM配置业务逻辑层                    |
| `restful/rag/internal/handler/llm_factories/` | NEW      | 厂商相关 Handler 层                      |
| `restful/rag/internal/handler/tenant_llm/`    | NEW      | 租户LLM配置 Handler 层                   |

### Model 层自定义方法

```go
// llm_factories_model.go

// 获取所有有效的厂商列表 (按rank降序)
func (m *customLlmFactoriesModel) FindAllActive(
    ctx context.Context,
) ([]*LlmFactories, error)

// tenant_llm_model.go

// 根据租户ID查询配置列表
func (m *customTenantLlmModel) FindListByTenantId(
    ctx context.Context>
    tenantId string,
    llmFactory, modelType string,
    status int64,
    page, pageSize int64,
) ([]*TenantLlm, int64, error)

// 按厂商分组查询
func (m *customTenantLlmModel) FindGroupedByFactory(
    ctx context.Context,
    tenantId string,
) (map[string][]*TenantLlm, error)

// 批量插入 (忽略冲突)
func (m *customTenantLlmModel) BatchInsertIgnore(
    ctx context.Context,
    records []*TenantLlm,
) (int64, error)
```

---

## 前端改动清单

### 类型定义

```typescript
// fe/src/types/llm.ts

export interface LlmFactoryInfo {
  name: string;
  logo: string;
  tags: string;
  tag_list: string[];
  rank: number;
  status: number;
}

export interface TenantLlmInfo {
  id: number;
  tenant_id: string;
  llm_factory: string;
  model_type: string;
  llm_name: string;
  api_key: string;
  api_base: string;
  max_tokens: number;
  used_tokens: number;
  status: number;
  created_time: number;
  updated_time: number;
}

export interface ModelConfig {
  model_type: string;
  llm_name: string;
  max_tokens?: number;
}

export interface AddTenantLlmRequest {
  llm_factory: string;
  api_key: string;
  api_base: string;
  models: ModelConfig[];
}

export interface TenantLlmGroupByFactory {
  llm_factory: string;
  factory_logo: string;
  api_base: string;
  models: TenantLlmInfo[];
}
```

### API 请求

```typescript
// fe/src/api/llm.ts

// 获取系统支持的厂商列表 (无需认证)
export const listLlmFactories = () =>
  request.get<{ list: LlmFactoryInfo[] }>('/llm/factories');

// 批量添加租户LLM配置
export const addTenantLlm = (data: AddTenantLlmRequest) =>
  request.post<{ success_count: number; failed_count: number; failed_models: string[] }>('/tenant/llm', data);

// 获取租户LLM配置列表
export const listTenantLlm = (params?: { llm_factory?: string; model_type?: string; status?: number }) =>
  request.get<{ total: number; list: TenantLlmInfo[] }>('/tenant/llm', { params });

// 获取租户LLM配置列表(按厂商分组)
export const listTenantLlmGrouped = () =>
  request.get<{ list: TenantLlmGroupByFactory[] }>('/tenant/llm/grouped');

// 更新租户LLM配置
export const updateTenantLlm = (id: number, data: Partial<TenantLlmInfo>) =>
  request.put(`/tenant/llm/${id}`, data);

// 删除租户LLM配置
export const deleteTenantLlm = (id: number) =>
  request.delete(`/tenant/llm/${id}`);
```

### 组件改动

| 文件路径                                              | 改动类型 | 说明                          |
| :---------------------------------------------------- | :------- | :---------------------------- |
| `fe/src/pages/settings/components/ModelList.tsx`      | REWRITE  | 改为按厂商分组展示            |
| `fe/src/pages/settings/components/AddModelDialog.tsx` | REWRITE  | 改为两步式: 选厂商 → 配置模型 |
| `fe/src/pages/settings/components/FactoryCard.tsx`    | NEW      | 厂商卡片组件                  |
| `fe/src/pages/settings/components/ProviderList.tsx`   | NEW      | 厂商列表展示                  |

### 新 UI 交互流程

1. **模型列表页** (`/settings/provider`)
   - 按厂商分组展示已配置的模型
   - 每个厂商卡片显示: Logo、名称、API状态、模型列表
   - 支持编辑、删除单个模型
   - 右上角【添加模型】按钮

2. **添加模型 Dialog** (两步式)
   - **Step 1**: 选择厂商
     - 网格展示所有支持的厂商 (Logo + Name)
     - 点击厂商进入 Step 2
   - **Step 2**: 配置模型
     - 显示该厂商支持的模型类型
     - 必填: API Key, API Base
     - 每个模型类型一个输入框 (可选)
     - 点击【确定】批量提交

---

## 完成标准

### ✅ 必须完成

1. **数据库**
   - [ ] 确认 `llm_factories` 表结构和初始数据
   - [ ] 确认 `tenant_llm` 表结构
   - [ ] 运行 `make gen-model` 生成 Model 代码

2. **后端 API**
   - [ ] 创建 `llm.api` 文件
   - [ ] 运行 `make gen-api` 生成代码
   - [ ] 实现 `ListLlmFactories` - 获取厂商列表
   - [ ] 实现 `AddTenantLlm` - 批量添加模型
   - [ ] 实现 `ListTenantLlm` - 获取模型列表
   - [ ] 实现 `ListTenantLlmGrouped` - 按厂商分组获取
   - [ ] 实现 `UpdateTenantLlm` - 更新模型配置
   - [ ] 实现 `DeleteTenantLlm` - 删除模型配置

3. **前端改造**
   - [ ] 添加 LLM 相关类型定义
   - [ ] 添加 LLM 相关 API 请求
   - [ ] 重写 `ModelList.tsx` - 按厂商分组展示
   - [ ] 重写 `AddModelDialog.tsx` - 两步式添加流程
   - [ ] 整体保持 Dify 风格

### ❌ 暂不实现

- 厂商管理后台 (增删改厂商)
- API Key 加密存储
- 模型连通性测试
- Token 用量统计和限制



# 第三阶段目标: 知识库多租户改造与搜索引擎迁移

> 实现知识库级别的多租户隔离，并将向量检索引擎从 Milvus 迁移至 Elasticsearch，采用 "文本-向量共存" (Text-Vector Co-Location) 架构。

---

## 核心变更

1.  **多租户隔离**: 知识库表新增 `tenant_id`，实现数据逻辑隔离。
2.  **ID 规范化**: 知识库、文档 ID 全面升级为 `UUID v7`。
3.  **搜索引擎迁移**: 放弃 Milvus，改用 **Elasticsearch**。
    -   **Text-Vector Co-Location**: 向量与文本存储在同一 ES 索引中，不再分离存储。
    -   **去除 MySQL 分片表**: MySQL 不再存储 `knowledge_document_chunk`，数据完全由 ES 接管。
4.  **接口封装**: 建立统一的 Go Interface (`ChunkModel`) 屏蔽底层搜索引擎差异。

---

## 数据库设计 (MySQL)

### 1. knowledge_base 表 (知识库)

> 存储知识库元数据，增加租户隔离和统计字段。

```sql
CREATE TABLE `knowledge_base`
(
    `id` varchar(36) NOT NULL COMMENT '主键ID, UUID v7',
    `avatar` longtext COMMENT '知识库头像 base64',
    `tenant_id` varchar(36) NOT NULL COMMENT '所属租户ID, 核心隔离字段',
    `name` varchar(64) NOT NULL COMMENT '知识库名称',
    `language` varchar(32) NOT NULL DEFAULT 'Chinese' COMMENT '语言: English|Chinese, 影响分词策略',
    `description` varchar(256) DEFAULT NULL COMMENT '描述',
    `embd_id` varchar(128) NOT NULL COMMENT 'Embedding模型ID (来自租户配置)',
    `permission` varchar(16) NOT NULL DEFAULT 'me' COMMENT '权限: me(仅创建者)|team(租户全员)',
    `created_by` varchar(36) NOT NULL COMMENT '创建者用户ID',
    `doc_num` bigint unsigned NOT NULL DEFAULT 0 COMMENT '文档数量',
    `token_num` bigint unsigned NOT NULL DEFAULT 0 COMMENT 'Token总数',
    `chunk_num` bigint unsigned NOT NULL DEFAULT 0 COMMENT '分片总数',
    `similarity_threshold` float NOT NULL DEFAULT 0.3 COMMENT '检索相似度阈值',
    `vector_similarity_weight` float NOT NULL DEFAULT 0.3 COMMENT '混合检索向量权重 (1-keyword)',
    `status` tinyint NOT NULL DEFAULT 1 COMMENT '状态: 1-启用, 0-禁用',
    `created_time` bigint NOT NULL COMMENT '创建时间戳(ms)',
    `updated_time` bigint NOT NULL COMMENT '更新时间戳(ms)',
    `created_date` datetime NOT NULL COMMENT '创建日期',
    `updated_date` datetime NOT NULL COMMENT '更新日期',
    `model_ids` json default (JSON_OBJECT()) comment '弱绑定模型配置',
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_tenant_id_name` (`tenant_id`, `name`),
    INDEX `idx_created_by` (`created_by`),
    INDEX `idx_permission` (`permission`),
    INDEX `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='知识库表';
```

### 2. knowledge_document 表 (文档)

> 存储文档元数据及处理状态。

```sql
CREATE TABLE `knowledge_document` (
  `id` char(36) NOT NULL COMMENT 'UUID v7',
  `knowledge_base_id` varchar(36) NOT NULL COMMENT '所属知识库ID',
  `doc_name` varchar(255) DEFAULT NULL COMMENT '文档名称',
  `doc_type` varchar(32) NOT NULL COMMENT '类型: pdf/word/txt/md',
  `doc_size` int(11) NOT NULL DEFAULT 0 COMMENT '大小(字节)',
  `description` varchar(256) DEFAULT NULL COMMENT '描述',
  `storage_path` varchar(255) DEFAULT NULL COMMENT '存储路径(MinIO)',
  `parser_config` longtext NOT NULL COMMENT '解析配置(JSON)',
  `source_type` varchar(128) NOT NULL DEFAULT 'local' COMMENT '来源: local/url',
  `created_by` varchar(36) NOT NULL COMMENT '上传者ID',
  `token_num` int(11) NOT NULL DEFAULT 0 COMMENT 'Token数',
  `chunk_num` int(11) NOT NULL DEFAULT 0 COMMENT '分片数',
  `progress` float NOT NULL DEFAULT 0 COMMENT '处理进度(0-1)',
  `progress_msg` longtext COMMENT '进度/错误信息',
  `process_begin_at` datetime DEFAULT NULL COMMENT '开始处理时间',
  `process_duration` float NOT NULL DEFAULT 0 COMMENT '处理耗时(s)',
  `run_status` varchar(32) NOT NULL DEFAULT 'pending' COMMENT '状态: pending/running/success/fail',
  `status` tinyint DEFAULT 1 COMMENT '状态: 1-有效, 0-删除',
  `created_time` bigint NOT NULL COMMENT '创建时间戳(ms)',
  `updated_time` bigint NOT NULL COMMENT '更新时间戳(ms)',
  `created_date` datetime NOT NULL COMMENT '创建日期',
  `updated_date` datetime NOT NULL COMMENT '更新日期',
  `meta_fields` longtext COMMENT '元数据',
  PRIMARY KEY (`id`),
  KEY `idx_doc_kb_id` (`knowledge_base_id`),
  KEY `idx_doc_name` (`doc_name`)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT ='文档表';
```

### 3. (删除) ~~knowledge_document_chunk 表~~

> ⚠️ **重要变更**: 废弃 MySQL 中的分片表，分片数据直接存储于 Elasticsearch。

---

## 搜索引擎设计 (Elasticsearch)

### 索引策略 (Index Strategy)

采用 **Shared Index with Routing** 策略：
- 全局使用一个（或按时间/业务切分）大索引 `rag_knowledge_chunks`。
- 通过 `kb_id` (Keyword) 进行过滤，模拟多租户/多知识库隔离。
- 优点：减少分片(Shard) 数量，避免每个租户/知识库一个索引导致的资源浪费。

### Mapping 定义 (Schema)

```json
{
  "mappings": {
    "properties": {
      "id": { "type": "keyword" },                // 唯一ID: xxhash(doc_id + content)
      "doc_id": { "type": "keyword" },            // 关联 MySQL document.id
      "kb_id": { "type": "keyword" },             // 关联 MySQL knowledge_base.id (数组，支持多库复用)
      "content_with_weight": {                    // 核心全文检索字段
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "q_1024_vec": {                             // 向量字段 (名称动态: q_{dim}_vec)
        "type": "dense_vector",
        "dims": 1024,
        "index": true,
        "similarity": "cosine"
      },
      "doc_name_keyword": { "type": "keyword" },  // 用于显示来源
      "important_keywords": { "type": "keyword" },// LLM提取关键词
      "question_keywords": { "type": "keyword" }, // LLM生成的问题
      "img_id": { "type": "keyword" },            // 图片ID
      "page_num_int": { "type": "integer" },      // 页码数组
      "position_int": { "type": "integer" },      // 坐标矩阵 [flattened]
      "available_int": { "type": "integer" },     // 1=可用, 0=不可用
      "create_timestamp_flt": { "type": "float" } // 时间戳排序
    }
  }
}
```

---

## 接口设计 (Go Interface)

### ChunkModel 接口

> 定义统一的文档分片操作接口，屏蔽 ES 实现细节。

```go
// internal/model/chunk/chunk_model.go

type Chunk struct {
    Id              string    `json:"id"`
    DocId           string    `json:"doc_id"`
    KbIds           []string  `json:"kb_ids"`      // 支持多库
    Content         string    `json:"content"`
    ContentVector   []float64 `json:"content_vector"` // q_{dim}_vec
    DocName         string    `json:"doc_name"`
    ImportantKw     []string  `json:"important_keywords"`
    QuestionKw      []string  `json:"question_keywords"`
    ImgId           string    `json:"img_id"`
    PageNum         []int     `json:"page_num_int"`
    CreateTime      float64   `json:"create_timestamp_flt"`
    Available       int       `json:"available_int"`
}

type ChunkModel interface {
    // 插入或更新分片
    Put(ctx context.Context, chunks []*Chunk) error
    
    // 混合检索 (Retriever使用)
    // 1. Keyword Search (content_with_weight)
    // 2. Vector Search (q_{dim}_vec)
    // 3. Filter by kb_id
    HybridSearch(ctx context.Context, kbId string, query string, vector []float64, topK int) ([]*Chunk, error)
    
    // 按文档ID删除 (用于删除文件)
    DeleteByDocId(ctx context.Context, kbId string, docId string) error
    
    // 按知识库ID删除 (用于删除知识库)
    DeleteByKbId(ctx context.Context, kbId string) error
}
```

---

## 业务流程修订

### 1. 文档解析与入库 (Pipeline)

1.  **解析**: 解析 PDF/Word，提取文本。
2.  **切片**: 根据规则切分 Text Chunk。
3.  **Embedding**: 调用 LLM (via `tenant_llm`) 生成 `q_{dim}_vec`。
4.  **Keyword**: (可选) 调用 LLM 提取 `important_keywords`。
5.  **存储**: 
    - 组装 `Chunk` 对象。
    - 调用 `ChunkModel.Put()` 存入 ES。
    - **不写入** MySQL Chunk 表。

### 2. 检索 (Retrieval)

1.  **用户 Query**: 用户输入问题。
2.  **Query Embedding**: 生成问题向量。
3.  **Search**: 
    - 调用 `ChunkModel.HybridSearch(kb_id, query, vector, top_k)`.
    - ES 内部执行 `bool` 查询: must[`kb_id` match], should[`vec` knn, `content` match].
4.  **Rerank**: (可选)如果不使用 ES 的 RRF，可在应用层做 Rerank。

---

## 权限控制修正

### 权限判断流程

1.  **知识库访问权限**:
    - 用户请求检索时，需先校验对 `kb_id` 的访问权限 (Query MySQL)。
    - 合法用户才能发起对 ES 的 Retrievel 请求。

2.  **数据隔离**:
    - ES 中每个 Chunk 带有 `kb_id`。
    - 检索时强制附加 `filter: { term: { kb_id: TargetKB } }`。
    - 即使是同一租户下的不同知识库，也严格隔离。

---



---

## 完成标准

### ✅ 必须完成

1.  **Schema 变更**
    - [ ] `knowledge_base` 表创建 (UUID, tenant_id)
    - [ ] `knowledge_document` 表创建 (UUID)
    - [ ] **删除** `knowledge_document_chunk` 表
    - [ ] 运行 `make gen-model`

2.  **ES 集成**
    - [x] 修改 `docker-compose.yml` 添加 Elasticsearch (7.x/8.x)
    - [x] **注释** Milvus 相关服务 (保留 Etcd/MinIO)
    - [ ] 初始化 ES 索引与 Mapping

3.  **后端实现**
    - [ ] 定义 `ChunkModel` 接口
    - [ ] 实现 `ChunkModelEs` (ES 版实现)
    - [ ] 注入 `ServiceContext`
    - [ ] 重构 `Retriever` 使用 `ChunkModel`

4.  **API 实现 (KnowledgeBase)**
    - [ ] KB管理接口 CRUD
    - [ ] 权限控制逻辑
    - [ ] (Pipeline) 解析入库流程改造适应 ES 




