# QA Checker 设计思路

## 核心目标
QA Checker 本质是对切分后的 `[]*schema.Document` 进行**质量检查与增强**，要解决的问题是：
- 确保每个 chunk 在检索阶段能被正常召回
- 确保每个 chunk 被作为上下文喂给 LLM 时能被正确理解

---

## 评分体系 (总分 100.0)

### 分项权重

| 指标       | 权重 | 满分 | 说明                      |
| ---------- | ---- | ---- | ------------------------- |
| 长度合理性 | 20%  | 20.0 | chunk 字数是否在合理范围  |
| 结构完整性 | 20%  | 20.0 | 句子是否完整，无截断      |
| 内容质量   | 20%  | 20.0 | 信息密度、重复度          |
| 语义完整性 | 20%  | 20.0 | 上下文独立性、指代词检测  |
| QA 质量分  | 20%  | 20.0 | QA 覆盖率、多样性、相关性 |

**总分公式**：
```
TotalScore = LengthScore + StructureScore + ContentScore + SemanticScore + QAScore
```

---

## 各指标计算规则

### 1. 长度合理性 (LengthScore) - 满分 20.0

| 字数范围 | 得分 | 说明           |
| -------- | ---- | -------------- |
| 300-800  | 20.0 | 最佳长度       |
| 100-299  | 12.0 | 稍短           |
| 801-1000 | 16.0 | 稍长           |
| < 100    | 6.0  | 过短，建议合并 |
| > 1000   | 10.0 | 过长，建议拆分 |

### 2. 结构完整性 (StructureScore) - 满分 20.0

| 检测项                 | 得分  | 说明       |
| ---------------------- | ----- | ---------- |
| 以句号/问号/感叹号结尾 | +10.0 | 句子完整   |
| 不以逗号/连词结尾      | +5.0  | 无截断痕迹 |
| 不以代词/指示词开头    | +5.0  | 无上文依赖 |

**截断词列表**：`但是`, `并且`, `因此`, `所以`, `然而`, `不过`
**指代词列表**：`它`, `他`, `她`, `这`, `那`, `该`, `其`

### 3. 内容质量 (ContentScore) - 满分 20.0

| 检测项   | 计算方式                           | 满分 |
| -------- | ---------------------------------- | ---- |
| 信息密度 | `(非空白字符数 / 总字符数) × 10.0` | 10.0 |
| 重复度   | `(1 - overlap比例) × 10.0`         | 10.0 |

**重复度计算**：
```
overlapRatio = (与前一个chunk的重复字数) / min(prevLen, currLen)
重复度得分 = (1 - overlapRatio) × 10.0
```

### 4. 语义完整性 (SemanticScore) - 满分 20.0

| 检测项     | 扣分规则       | 说明             |
| ---------- | -------------- | ---------------- |
| 代词数量   | 每个代词扣 2.0 | 最多扣 10.0      |
| 截断指示符 | 每个扣 3.0     | 以连词开头/结尾  |
| 孤立引用   | 每个扣 2.0     | 未定义的术语引用 |

**计算公式**：
```
SemanticScore = max(0, 20.0 - 代词扣分 - 截断扣分 - 引用扣分)
```

### 5. QA 质量分 (QAScore) - 满分 20.0

| 子指标 | 权重 | 计算方式                            |
| ------ | ---- | ----------------------------------- |
| 覆盖率 | 50%  | `min(QA数量 / 3, 1.0) × 10.0`       |
| 多样性 | 25%  | `(1 - 重复开头数/总问题数) × 5.0`   |
| 相关性 | 25%  | `(问题关键词匹配数/总问题数) × 5.0` |

**QA 覆盖率判定**：
- QA 数量 ≥ 3：满分
- QA 数量 = 2：6.7 分
- QA 数量 = 1：3.3 分
- QA 数量 = 0：0 分 → **触发 LLM 生成**

---

## 质量阈值

| 场景         | 阈值                     | 处理方式           |
| ------------ | ------------------------ | ------------------ |
| 高质量 chunk | TotalScore ≥ 80.0        | 直接通过           |
| 中等质量     | 60.0 ≤ TotalScore < 80.0 | 标记警告           |
| 低质量 chunk | TotalScore < 60.0        | 标记问题，生成建议 |
| 触发 QA 生成 | QA 数量 < 2              | 调用 LLM 生成 QA   |

---

## 问题与建议列表

### 问题类型 (Issues)

| 问题 ID              | 说明        | 触发条件        |
| -------------------- | ----------- | --------------- |
| `chunk_too_short`    | chunk 过短  | 字数 < 100      |
| `chunk_too_long`     | chunk 过长  | 字数 > 1000     |
| `truncated_end`      | 句子被截断  | 以逗号/连词结尾 |
| `dangling_reference` | 指代不明    | 以代词开头      |
| `low_qa_coverage`    | QA 覆盖不足 | QA 数量 < 2     |
| `high_overlap`       | 重复度过高  | overlap > 50%   |

### 建议类型 (Suggestions)

| 建议 ID           | 说明                    |
| ----------------- | ----------------------- |
| `merge_with_prev` | 考虑与前一个 chunk 合并 |
| `merge_with_next` | 考虑与后一个 chunk 合并 |
| `split_further`   | 考虑进一步拆分          |
| `extend_boundary` | 调整边界以保留完整句子  |
| `generate_qa`     | 需要生成 QA 问答对      |

---

## QA 生成流程

```
1. 遍历所有 chunk，计算初始 QA 覆盖率
2. 筛选 QA 数量 < 2 的 chunk
3. 批量调用 LLM 生成 QA (每个 chunk 生成 3-5 个)
4. 将生成的 QA 存入 doc.MetaData["qa_pairs"]
5. 重新计算 QAScore
6. 计算最终 TotalScore
```

---

## QA 生成 Prompt

```go
systemPrompt := fmt.Sprintf(`你是一个专业的RAG数据集生成专家。你的任务是基于提供的文本内容生成高质量的问答对。
知识库名称：《%s》

### 生成要求：
1. **格式严格**：必须输出标准的 JSON 数组格式，不要包含 Markdown 标记。
2. **独立性（关键）**：生成的问题必须是"独立可理解的"。
   - ❌ 错误案例："由于这个原因，导致了什么后果？"
   - ✅ 正确案例："在《%s》中，导致服务器宕机的主要原因是什么？"
3. **内容来源**：严格基于文本，不要使用外部知识。
4. **多样性**：
   - 包含事实型问题（What, When, Who）
   - 包含推理型问题（Why, How）
   - 包含条件型问题（If...）

### 质量控制规则：
1. **拒绝代词**：问题中不能出现"他"、"它"、"这"等指代不明的词汇。
2. **拒绝是非题**：多生成"是什么"、"怎么做"的问题。
3. **包含元数据**：体现时间、地点、版本号等限定条件。

### 输出格式：
[
  {"question": "问题内容", "answer": "简短答案"},
  ...
]
`, knowledgeName, knowledgeName)
```

---

## 数据结构定义

```go
// QAItem QA 问答对
type QAItem struct {
    Question string `json:"question"`
    Answer   string `json:"answer"`
}

// ChunkQualityScore chunk 质量评分结果
type ChunkQualityScore struct {
    TotalScore     float64  // 总分 (0-100)
    LengthScore    float64  // 长度合理性 (0-20)
    StructureScore float64  // 结构完整性 (0-20)
    ContentScore   float64  // 内容质量 (0-20)
    SemanticScore  float64  // 语义完整性 (0-20)
    QAScore        float64  // QA 质量分 (0-20)
    Issues         []string // 问题列表
    Suggestions    []string // 建议列表
}
```


# 补充1
内容过短的chunk，强行生成QA只会产生垃圾数据。
比如：“它很好用”
生成的QA：
- Q: 在《/docs/go-intro.md》中提到的物品好用程度如何？
- A: 很好用
- Q: 如果一个物品被《/docs/go-intro.md》描述为很好用，那么它在实际使用中可能会有怎样的表现？
- A: 推测可能使用顺畅、效果好等

解决方案（两种组合）
1. QA checker 阶段：对于这种内容过短的chunk (len < 100 或质量分<50)则不生成QA，跳过LLM生成
2. QA checker 阶段：在metadata中保留 issues和suggestions，供后续流程使用


