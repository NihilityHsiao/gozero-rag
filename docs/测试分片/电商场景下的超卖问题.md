[使用Tair设计与实现高并发秒杀系统-云数据库Tair-阿里云](https://help.aliyun.com/zh/redis/use-cases/use-apsaradb-for-redis-to-build-a-business-system-that-can-handle-flash-sales)
[Fetching Title#v4j8](https://github.com/resumejob/How-to-design-a-spike-system?tab=readme-ov-file)
[Fetching Title#3gua](https://github.com/GuoZhaoran/spikeSystem)
[GitHub - yxhsea/SecKill: 这是基于Go语言的一个秒杀系统。](https://github.com/yxhsea/SecKill)
[这个是真的厉害，高并发场景下的订单和库存处理方案，讲的很详细了！之前一直有小伙伴私信我问我高并发场景下的订单和库存处理方 - 掘金](https://juejin.cn/post/6850037282246754318)




超卖是电商领域中一个常见且棘手的问题。尤其是在多平台销售模式下，由于库存同步的延迟或机制的缺陷，极易导致实际销售数量超过库存总量的现象，造成用户体验下降，甚至引发法律纠纷。本文将针对这一问题，结合实际业务场景，探讨几种常见的解决方案及其优缺点。

# 一、业务场景及其解决方案

## 1.1 多平台销售的库存同步问题

假设我们有一个商品，总库存为 10 件，同时在天猫、京东、拼多多三个平台销售。

天猫：显示库存 10 件
京东：显示库存 10 件
拼多多：显示库存 10 件
在这种情况下，如果三个平台的销售并发很高，就可能出现总销量超过 10 件，导致超卖 20 件的尴尬局面。


### 方案 1：库存分配

将总库存按照一定的**权重**分配给各个平台，每个平台独立管理自己的库存，平台之间互不影响。
例如，天猫分配 4 件，京东分配 3 件，拼多多分配 3 件。
**优点：**
- 实现简单，易于管理。
- 避免了平台之间的库存竞争，降低了超卖的风险。
**缺点：**
- 可能导致部分平台库存积压，而其他平台却供不应求，降低了整体的库存周转率。
- 需要合理的权重分配策略，才能最大程度地提升销售额。

#### 库存分配权重的确定

**如何确定权重呢？** 我们可以引入如下权重因子：
- 近 30 日销量占比（占据 50%的权重）
- 平台转化率（30%权重，支付订单数 ➗ 总访问）
- 平台客单价（20%权重）
分配比例 = `0.5*销量占比 + 0.3*转化占比 + 0.2*客单价` 




### 方案 2：预留库存（安全库存）

在实际库存的基础上，预留一部分作为安全库存，对外展示的库存量小于实际库存量。例如，实际库存 100 件，对外显示 90 件，预留 10% 的安全库存，用于处理退货、换货、损坏等意外情况（应对不确定的缓冲）
**优点：**
- 可以有效应对突发情况，保证部分订单的正常交付。
- 降低了超卖的风险。
**缺点：**
- 降低了库存的利用率，可能会损失一部分销售额。
- 安全库存的比例需要根据历史数据和业务经验进行调整。


具体需要预留多少商品，可以基于历史数据建立预测模型，可以参考的数据有：
- 退货率
- 换货率
- 质量问题（损坏/残次）
- 物流丢失
- 其他异常

基础预留 = 退货+换货+异常。假定基础预留 10%，那么实际预留可以动态调整处于 5%-15%这个区间




### 方案 3：限制购买量
限制用户单次只能购买 1 件商品

### 方案 4：预售模式
不直接展示库存量，只接受用户的预定。根据预定数量，进行按需采购，避免库存积压。
**优点：**
- 可以有效避免超卖和库存积压。
- 降低了库存管理的成本。
**缺点：**
- 发货周期长，用户体验较差。
- 可能需要用户等待较长时间才能收到商品。




## 1.2 超卖后的补救措施

1. APP/短信通知，发起补救流程
2. 客服介入主动沟通
    - 全额退款+10%优惠券
    - 等待时间补货，从其他仓库/平台调货 +优惠券
    - 推荐其他同类商品
3. 必要时亏本发货



# 二、自营电商场景防超卖的技术实现

很多大商家都是多平台、多渠道、多店铺销售。不同的渠道对于上架数量的逻辑也不同。比如淘宝支持拍下减库存和付款减库存。
下文讨论【自营电商】在高并发的秒杀场景下如何实现防超卖。


一个秒杀活动可以分成三个阶段：
- 秒杀前：用户不断刷新商品详情，等待倒计时
- 秒杀开始：用户反复点击秒杀按钮，此时是整个系统中的流量巅峰
- 秒杀后：一部分用户反复查看订单，或产生退单。另一部分用户不断刷新商品详情，等待商品库存释放继续购买。


秒杀系统的瞬时流量高，但是最终进入到业务系统的流量是很少的，整体思路是采用 "漏斗模型"过滤掉大部分流量。

## 秒杀前
第 1 层：CDN/前端限流。
- 将商品详情页面做元素静态化处理，这样就可以把数据缓存在浏览器和 CDN 上。
- 只有点击秒杀按钮的时候流量才会进入到服务端。
- 添加图形验证码，过滤机器人和重复请求


在秒杀开始前，可以提前将秒杀商品缓存到读写分离的Redis：

```json
{
    "product_id": "商品id",
    "product_count": 100, // 商品总数
    "start": 0,  // 秒杀活动是否开启, 0-未开启; 1-开启
    "access": 0, // 接受下单数
}
```
## 秒杀开始
```json
{
    "product_id": "商品id",
    "product_count": 100, // 商品总数
    "start": 0,  // 秒杀活动是否开启, 0-未开启; 1-开启
    "access": 0, // 接受下单数
}
```
将 `start` 设置为 1，标记秒杀开始
整个服务端开始接受请求，记录到redis 中的 `access` 
当 `access` 达到 `product_count` 之后，拦截所有请求。
最后只有成功 **参与下单** 的请求只有 100 个。

在高并发的情况下，这个数量可能会超过 100，但不会太多。


---

成功参与下单之后，用户点击“提交订单”，这时候可以进行订单信息校验/扣库存了。






## 秒杀后



## 库存扣减时机

## 分布式锁的设计

```md
锁的粒度选择：

方案A：商品级锁
  锁key：lock:product:12345
  粒度：整个商品
  
  问题：
  - 所有购买该商品的用户都排队
  - 如果库存100件，也只能串行处理
  - 性能差（QPS < 100）

方案B：库存分段锁（我的选择）
  锁key：
    lock:product:12345:segment:1（库存1-20）
    lock:product:12345:segment:2（库存21-40）
    ...
  
  优点：
  - 并发度提升5倍
  - 不同段的库存可以并行扣减
  
  缺点：
  - 复杂度增加
  - 需要合理分段

方案C：用户级锁（辅助）
  锁key：lock:user:123456
  
  作用：
  - 防止用户重复提交
  - 用户只能有1个进行中的订单

我的最终方案：
  商品分段锁（主）+ 用户级锁（辅）
  
锁超时时间：
  正常：5秒
  大促：10秒（因为数据库压力大）
  
  太短：可能业务未完成就超时
  太长：锁占用时间长，性能差

获取锁失败的处理：
  方案A：等待重试（最多3次，每次1秒）
  方案B：立即提示"系统繁忙，请稍后重试"
  
  我选择：方案B
  原因：
  - 快速失败，不让用户傻等
  - 用户可以立即重试
  - 服务器压力小
```
## 数据一致性保证
## 秒杀场景优化
```md
场景：1000件，10万人抢

我会采用"漏斗模型"：

第1层：CDN/前端限流
  10万请求 → 前端验证码/滑块
  → 过滤机器人和重复请求
  → 剩余5万有效请求

第2层：接入层限流
  5万请求 → Nginx限流（令牌桶）
  → 每秒只放行1000个请求
  → 其他进入等待队列

前置拦截，随机丢弃90%+的请求，能解决很大部分问题了

第3层：业务层排队
  1000个请求/秒 → 排队系统
  → 实时显示："前方还有237人"
  → 心理预期管理

第4层：数据库层
  → Redis缓存库存（预检）
  → MySQL扣减（只有通过前3层的才到这）
  → 此时QPS已降到可控范围

第5层：降级兜底
  如果库存售罄：
  → 自动转预售
  → 或推荐替代商品

关键技术：
- 页面静态化（CDN）
- Redis缓存（库存预检）
- 消息队列（削峰填谷）
- 限流算法（令牌桶/漏桶）

优化效果：
  原本：10万QPS直接打到数据库 → 崩溃
  优化后：最多1000 QPS到数据库 → 稳定
```
## 监控和预警
## 异常场景处理机制

### 库存中心挂了怎么办

### 弱网支付

弱网环境下支付的问题主要涉及到在网络信号较差的情况下进行支付操作时可能出现的一系列问题。

弱网环境最主要的是要解决支付状态同步的问题，它的解决方案有以下几个：

支付平台提供回调方法进行支付状态的刷新。
手动触发主动出查询得到支付状态。
定时任务进行刷新。


### 刷单
防止黄牛刷单的常见解决方案有以下两种：

添加图形验证码：此手段可以解决大部分刷单问题。
添加异常观测平台和 IP 黑名单限制：通过异常报警平台观察到异常 IP，然后将异常 IP，加入到 IP 黑名单，从而解决刷单问题。


### 重复订单
重复订单去重问题的解决方案有以下两个：

通过幂等性判断去除重复订单：可以通过自定义注解 + Redis 来实现幂等性过滤。
数据库唯一约束保底：数据库通过设置唯一约束来保证不会有重复的订单添加到数据库，从而避免了重复订单的产生。