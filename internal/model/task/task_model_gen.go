// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package task

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	taskFieldNames          = builder.RawFieldNames(&Task{})
	taskRows                = strings.Join(taskFieldNames, ",")
	taskRowsExpectAutoSet   = strings.Join(stringx.Remove(taskFieldNames, "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	taskRowsWithPlaceHolder = strings.Join(stringx.Remove(taskFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheTaskIdPrefix = "cache:task:id:"
)

type (
	taskModel interface {
		Insert(ctx context.Context, data *Task) (sql.Result, error)
		FindOne(ctx context.Context, id string) (*Task, error)
		Update(ctx context.Context, data *Task) error
		Delete(ctx context.Context, id string) error
	}

	defaultTaskModel struct {
		sqlc.CachedConn
		table string
	}

	Task struct {
		Id              string         `db:"id"`               // 任务唯一ID (UUID)
		DocId           string         `db:"doc_id"`           // 关联的文档ID
		TaskType        string         `db:"task_type"`        // 任务类型: parse, graphrag,后期考虑实现raptor模型
		FromPage        int64          `db:"from_page"`        // 起始页/行 (包含)
		ToPage          int64          `db:"to_page"`          // 结束页/行 (不包含)
		Progress        float64        `db:"progress"`         // 任务进度 0.0-1.0
		Status          string         `db:"status"`           // 状态: pending | running | success | fail | paused
		ProgressMsg     sql.NullString `db:"progress_msg"`     // 当前进度的详细日志/最后一条消息
		FailReason      sql.NullString `db:"fail_reason"`      // 如果失败，记录具体堆栈或错误信息
		RetryCount      int64          `db:"retry_count"`      // 重试次数
		Digest          string         `db:"digest"`           // 任务配置摘要Hash，用于检测重复任务/断点续传,如果一个文档的某个片段（分片），其内容范围和解析配置完全没有变，那么就直接复用上次的结果，不再重新跑 ORC/LLM。
		ChunkIds        sql.NullString `db:"chunk_ids"`        // 该任务生成的切片ID列表(空格或逗号分隔)，用于清理旧数据
		ProcessDuration float64        `db:"process_duration"` // 处理耗时(秒)
		CreatedTime     int64          `db:"created_time"`     // 创建时间戳(ms)
		UpdatedTime     int64          `db:"updated_time"`     // 更新时间戳(ms)
		CreatedDate     time.Time      `db:"created_date"`     // 创建日期
		UpdatedDate     time.Time      `db:"updated_date"`     // 更新日期
		DeleteAt        sql.NullTime   `db:"delete_at"`        // 软删除标记
	}
)

func newTaskModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultTaskModel {
	return &defaultTaskModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`task`",
	}
}

func (m *defaultTaskModel) Delete(ctx context.Context, id string) error {
	taskIdKey := fmt.Sprintf("%s%v", cacheTaskIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, taskIdKey)
	return err
}

func (m *defaultTaskModel) FindOne(ctx context.Context, id string) (*Task, error) {
	taskIdKey := fmt.Sprintf("%s%v", cacheTaskIdPrefix, id)
	var resp Task
	err := m.QueryRowCtx(ctx, &resp, taskIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", taskRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultTaskModel) Insert(ctx context.Context, data *Task) (sql.Result, error) {
	// --------------------------------------------------------------------------------
	// [AUTO-FILL] 自动填充时间 (NOT NULL 版本)
	// --------------------------------------------------------------------------------
	now := time.Now()
	nowUnix := now.UnixMilli()
	// 直接赋值 int64，不需要 sql.NullInt64
	data.CreatedTime = nowUnix
	data.UpdatedTime = nowUnix

	// 直接赋值 time.Time，不需要 sql.NullTime
	data.CreatedDate = now
	data.UpdatedDate = now
	// --------------------------------------------------------------------------------

	taskIdKey := fmt.Sprintf("%s%v", cacheTaskIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, taskRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Id, data.DocId, data.TaskType, data.FromPage, data.ToPage, data.Progress, data.Status, data.ProgressMsg, data.FailReason, data.RetryCount, data.Digest, data.ChunkIds, data.ProcessDuration, data.CreatedTime, data.UpdatedTime, data.CreatedDate, data.UpdatedDate, data.DeleteAt)
	}, taskIdKey)
	return ret, err
}

func (m *defaultTaskModel) Update(ctx context.Context, data *Task) error {
	// --------------------------------------------------------------------------------
	// [AUTO-FILL] 自动更新时间 (NOT NULL 版本)
	// --------------------------------------------------------------------------------
	now := time.Now()

	// 直接赋值，Update 操作只需更新 update_xxx 字段
	data.UpdatedTime = now.UnixMilli()
	data.UpdatedDate = now
	// --------------------------------------------------------------------------------

	taskIdKey := fmt.Sprintf("%s%v", cacheTaskIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, taskRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.DocId, data.TaskType, data.FromPage, data.ToPage, data.Progress, data.Status, data.ProgressMsg, data.FailReason, data.RetryCount, data.Digest, data.ChunkIds, data.ProcessDuration, data.CreatedTime, data.UpdatedTime, data.CreatedDate, data.UpdatedDate, data.DeleteAt, data.Id)
	}, taskIdKey)
	return err
}

func (m *defaultTaskModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheTaskIdPrefix, primary)
}

func (m *defaultTaskModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", taskRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultTaskModel) tableName() string {
	return m.table
}
